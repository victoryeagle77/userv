use rusqlite::Connection;
use std::{
    error::Error,
    path::Path,
    thread::sleep,
    time::{Duration, Instant},
};

/// SQLite database file path.
const DATABASE: &str = "log/data.db";

/// SMBIOS provides a structure called Entry Point Structure (EPS) that contains a pointer to the SMBIOS Structure Table and some additional information.
pub const ENTRY_BIN: &str = "/sys/firmware/dmi/tables/smbios_entry_point";
/// DMI table that contains a description of the system's hardware components.
pub const DMIDECODE_BIN: &str = "/sys/firmware/dmi/tables/DMI";

/// Supported types for SQLite database.
#[derive(Debug, PartialEq)]
pub enum SQLiteType {
    /// Signed integers numbers (1 to 8 bytes).
    Integer,
    /// Float numbers with double precision decimal part (8 bytes).
    Real,
    /// String stored with various encodes (UTF-8, UTF-16).
    Text,
    /// Natural binary data (images, files...).
    Blob,
    /// Missing or not define value.
    Null,
}

impl SQLiteType {
    /// Convert fields of the [`SQLiteType`] enumeration.
    ///
    /// # Returns
    ///
    /// String usable for SQLite request integration.
    pub fn as_str(&self) -> &'static str {
        match self {
            SQLiteType::Integer => "INTEGER",
            SQLiteType::Real => "REAL",
            SQLiteType::Text => "TEXT",
            SQLiteType::Blob => "BLOB",
            SQLiteType::Null => "NULL",
        }
    }
}

/// Available key attributes for SQLite database.
#[derive(Debug, PartialEq)]
pub enum SQLiteKey {
    /// Unique value identifying each lines of database.
    Primary,
    /// Unique value referencing other tables in database.
    Foreign,
    /// No key specified.
    None,
}

impl SQLiteKey {
    /// Convert fields of the [`SQLiteKey`] enumeration.
    ///
    /// # Returns
    ///
    /// String usable for SQLite request integration.
    pub fn as_str(&self) -> &'static str {
        match self {
            SQLiteKey::Primary => "PRIMARY KEY",
            SQLiteKey::Foreign => "FOREIGN KEY",
            SQLiteKey::None => "",
        }
    }
}

/// Available option for SQLite database.
#[derive(Debug, PartialEq)]
pub enum SQLiteOption {
    /// Prevent SQLite to reuse a value that has not been used.
    Autoincrement,
    // Ensures all values are distinct from one another or unique.
    Unique,
    /// No option specified.
    None,
}

impl SQLiteOption {
    /// Convert fields of the [`SQLiteOption`] enumeration.
    ///
    /// # Returns
    ///
    /// String usable for SQLite request integration.
    pub fn as_str(&self) -> &'static str {
        match self {
            SQLiteOption::Autoincrement => "AUTOINCREMENT",
            SQLiteOption::Unique => "UNIQUE",
            SQLiteOption::None => "",
        }
    }
}

/// Descriptor for a SQL field.
#[derive(Debug, PartialEq)]
pub struct SqlFieldDescriptor {
    /// Name of the SQL field.
    pub field_name: &'static str,
    /// Unit of the SQL field concatenated to the name.
    pub field_unit: Option<&'static str>,
    /// Definition type among [`SQLiteType`] of a parameter in database.
    pub field_type: SQLiteType,
    /// Define if a value must to be not null or not.
    pub field_not_null: bool,
    /// Key among [`SQLiteKey`] for unique parameter for a table.
    pub field_key: SQLiteKey,
    /// Option among [`SQLiteOption`] for specifying the behavior of a parameter.
    pub field_options: SQLiteOption,
}

/// Build dynamically the SQl request of values insertion in database.
/// Excluding the autogenerated auto-incremented primary key field.
///
/// # Arguments
///
/// - `table_name`: Name of the main SQL table to store parameters.
/// - `field`: Field coming from [`SqlFieldDescriptor`] defining a parameter in database.
///
/// # Returns
///
/// - `query`: Formatted string corresponding to the SQL request.
pub fn db_insert_query(
    table_name: &str,
    field: &[SqlFieldDescriptor],
) -> Result<String, Box<dyn Error>> {
    let filtered_fields: Vec<String> = field
        .iter()
        .filter(|desc| desc.field_key != SQLiteKey::Primary)
        .map(|d| {
            let mut name = d.field_name.to_string();
            if let Some(unit) = d.field_unit {
                name.push('_');
                name.push_str(unit);
            }
            name
        })
        .collect();

    let placeholders: Vec<String> = (1..=filtered_fields.len())
        .map(|i| format!("?{i}"))
        .collect();

    let query = format!(
        "INSERT INTO {} ({}) VALUES ({});",
        table_name,
        filtered_fields.join(","),
        placeholders.join(",")
    );

    Ok(query)
}

/// Build statically the SQl request of values insertion in database.
/// Excluding the autogenerated auto-incremented primary key field.
///
/// # Arguments
///
/// - `table_name`: Name of the main SQL table to store parameters.
/// - `field`: Field coming from [`SqlFieldDescriptor`] defining a parameter in database.
/// - `conflict_param`:
/// - `update_param`:
///
/// # Returns
///
/// - `index`:
/// - `query`: Formatted string corresponding to the SQL request.
pub fn db_insert_unique(
    table_name: &str,
    field: &[SqlFieldDescriptor],
    conflict_param: &[&str],
    update_param: &[&str],
) -> Result<(Option<String>, String), Box<dyn Error>> {
    let index = if !conflict_param.is_empty() {
        Some(format!(
            "CREATE UNIQUE INDEX IF NOT EXISTS idx_{}_unique ON {}({});",
            table_name,
            table_name,
            conflict_param.join(", ")
        ))
    } else {
        None
    };

    let insert_field: Vec<String> = field
        .iter()
        .filter(|f| f.field_key != SQLiteKey::Primary)
        .map(|f| {
            let mut name = f.field_name.to_string();
            if let Some(unit) = f.field_unit {
                name.push('_');
                name.push_str(unit);
            }
            name
        })
        .collect();

    if insert_field.is_empty() {
        return Err("DataBase 'No injectable fields given'".into());
    }

    let placeholders: Vec<String> = (1..=insert_field.len()).map(|i| format!("?{i}")).collect();
    let conflict = conflict_param.join(", ");

    let update_columns: Vec<String> = insert_field
        .iter()
        .filter(|col| !update_param.contains(&col.as_str()))
        .cloned()
        .collect();

    let update_str = if update_columns.is_empty() {
        String::new()
    } else {
        update_columns
            .iter()
            .map(|col| format!("{} = excluded.{}", col, col))
            .collect::<Vec<_>>()
            .join(", ")
    };

    let query = if update_str.is_empty() {
        format!(
            "INSERT INTO {} ({}) VALUES ({}) ON CONFLICT({}) DO NOTHING;",
            table_name,
            insert_field.join(", "),
            placeholders.join(", "),
            conflict,
        )
    } else {
        format!(
            "INSERT INTO {} ({}) VALUES ({}) ON CONFLICT({}) DO UPDATE SET {};",
            table_name,
            insert_field.join(", "),
            placeholders.join(", "),
            conflict,
            update_str,
        )
    };

    Ok((index, query))
}

/// Generating the SQL declaration of a field in database, with concatenation of various parameters.
///
/// # Arguments
///
/// - `field`: Field coming from [`SqlFieldDescriptor`] defining a parameter in database.
pub fn db_field_declaration(field: &SqlFieldDescriptor) -> String {
    let mut decl = field.field_name.to_string();

    if let Some(unit) = field.field_unit {
        decl.push('_');
        decl.push_str(unit);
    }

    decl.push(' ');
    decl.push_str(field.field_type.as_str());

    if field.field_not_null {
        decl.push(' ');
        decl.push_str("NOT NULL");
    }

    decl.push(' ');
    decl.push_str(field.field_key.as_str());

    decl.push(' ');
    decl.push_str(field.field_options.as_str());

    decl
}

/// Create the SQL table request dynamically.
///
/// # Arguments
///
/// - `table_name`: Name of the main SQL table to store parameters.
/// - `field`: Field coming from [`SqlFieldDescriptor`] defining a parameter in database.
///
/// # Returns
///
/// - `query`: Formatted string corresponding to the SQL request.
pub fn db_table_query_creation(
    table_name: &str,
    field: &[SqlFieldDescriptor],
) -> Result<String, Box<dyn Error>> {
    if field.is_empty() {
        return Err("Data 'Empty field, impossible to create table'".into());
    }

    let decl: Vec<String> = field.iter().map(db_field_declaration).collect();
    let query = format!(
        "CREATE TABLE IF NOT EXISTS {} ({});",
        table_name,
        decl.join(",\n"),
    );

    Ok(query)
}

/// Initialize the SQLite database connection and create table if needed.
///
/// # Arguments
///
/// - `path` : File path to save the SQLite database.
/// - `request` : Request to use for database file.
///
/// # Returns
///
/// - A [`Connection`] constructor to initialize database parameters.
/// - An error if table creation or database initialization failed.
fn db_config<P: AsRef<Path>>(path: P, query: &str) -> Result<Connection, Box<dyn Error>> {
    let conn = Connection::open(path)?;
    conn.execute_batch(query)?;
    Ok(conn)
}

/// Call [`db_config`] function to initialize and create a SQLite database,
/// and using the static path [`DATABASE`] to save it.
///
/// # Arguments
///
/// - `request` : Request to use for database file.
///
/// # Returns
///
/// - A [`Connection`] constructor to initialize database parameters.
/// - An error if table creation or database initialization failed.
pub fn init_db(query: &str) -> Result<Connection, Box<dyn Error>> {
    db_config(DATABASE, query)
}

/// Measure the average variation of a value measurement on a given time interval.
/// We ignore previous data if is not exist.
///
/// # Arguments
///
/// - `measurement` : closure returning the current value of the measurement.
/// - `delay` : Time interval between 2 measures.
///
/// # Return
///
/// The calculated average difference for a measure.
pub fn measure_point<F>(measurement: F, delay: Duration) -> Option<f64>
where
    F: Fn() -> Option<f64>,
{
    let start_value = measurement();
    match start_value {
        None => measurement(),
        Some(next) => {
            let start_time = Instant::now();
            sleep(delay);
            let end_value = measurement();

            match end_value {
                None => None,
                Some(prev) => {
                    if prev < next {
                        None
                    } else {
                        let elapsed = start_time.elapsed().as_secs_f64();
                        Some((prev - next) / elapsed)
                    }
                }
            }
        }
    }
}

//----------------//
// UNIT CODE TEST //
//----------------//

#[cfg(test)]
mod tests {
    use super::*;
    use std::{
        sync::atomic::{AtomicUsize, Ordering},
        time::Duration,
    };
    use tempfile::NamedTempFile;

    // Test `init_db` function with temporary path
    #[test]
    fn test_init_db_creates_table_tempfile() {
        let temp = NamedTempFile::new().expect("Temp file creation failed");
        let path = temp.path();

        let sql = "CREATE TABLE IF NOT EXISTS test_table (id INTEGER PRIMARY KEY, value TEXT);";
        let conn = db_config(path, sql).expect("init_db should succeed");

        conn.execute("INSERT INTO test_table (value) VALUES (?1)", &[&"hello"])
            .expect("Insert should succeed");

        let count: i64 = conn
            .query_row("SELECT COUNT(*) FROM test_table", [], |row| row.get(0))
            .expect("Select should succeed");

        assert_eq!(count, 1);
    }

    // Test `init_db` function
    #[test]
    fn test_init_db_invalid_sql() {
        let sql = "CREATE TABLE bad_syntax";
        let res = init_db(sql);
        assert!(res.is_err());
    }

    // Test `measure_point` function with increasing value value
    #[test]
    fn test_measure_point_increasing_value() {
        fn get_value() -> f64 {
            static VALUE: AtomicUsize = AtomicUsize::new(1);
            let v = VALUE.fetch_add(1, Ordering::SeqCst);
            v as f64
        }

        let measurement = || Some(get_value());
        let res = measure_point(measurement, Duration::from_millis(50));
        assert!(res.is_some());
        assert!(res.unwrap() > 0.0);
    }

    // Test `measure_point` function with no start value to use for measurement count
    #[test]
    fn test_measure_point_no_init() {
        static VALUE: AtomicUsize = AtomicUsize::new(0);

        let measurement = || {
            let count = VALUE.fetch_add(1, Ordering::SeqCst);
            if count == 0 { None } else { Some(42.0) }
        };

        let res = measure_point(measurement, Duration::from_millis(10));
        assert_eq!(res, Some(42.0));
    }

    // Test `measure_point` function with a previous value bigger than next value retrieved
    #[test]
    fn test_measure_point_error_diff() {
        static VALUE: AtomicUsize = AtomicUsize::new(0);

        let measurement = || {
            let count = VALUE.fetch_add(1, Ordering::SeqCst);
            match count {
                0 => Some(10.0),
                1 => Some(5.0),
                _ => None,
            }
        };

        let res = measure_point(measurement, Duration::from_millis(10));
        assert_eq!(res, None);
    }

    // Test `measure_point` function with count error
    #[test]
    fn test_measure_point_error() {
        static VALUE: AtomicUsize = AtomicUsize::new(0);

        let measurement = || {
            let count = VALUE.fetch_add(1, Ordering::SeqCst);
            if count == 0 { Some(10.0) } else { None }
        };

        let res = measure_point(measurement, Duration::from_millis(10));
        assert_eq!(res, None);
    }
}
